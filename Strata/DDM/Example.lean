/-
  Copyright Strata Contributors

  SPDX-License-Identifier: Apache-2.0 OR MIT
-/

import Strata.DDM.Integration.Lean
import Strata.DDM.Util.Format
import Strata.DDM.BuilderM

#dialect
dialect B3Lite;

type Pred;
fn btrue : Pred => "true";
fn implies (p : Pred, q : Pred) : Pred => @[prec(20), rightassoc] p " ==> " q;

type Nat;

category Statement;
category Block;

@[declare(v, tp)]
op assign (tp : Type, v : Ident, a : tp) : Statement => "assign" "(" tp:40 ", " v:40 ", " a:40 ")" ";\n";
op if (c : Pred, t : Block, f : Block) : Statement => "if " "(" c:0 ")" t:50 "else " f:50;

op block (c : Seq Statement) : Block => " {\n" indent(2, c:40) "}\n";

category Binding;
@[declare(name, tp)]
op mkBinding (name : Ident, tp : Type) : Binding => @[prec(40)] name ":" tp;

category Bindings;
@[scope(bindings)]
op mkBindings (bindings : CommaSepBy Binding) : Bindings => "(" bindings ")";

op assert (p : Pred) : Command => @[prec(10)] "assert " p ";\n";
op procedure (name : Ident, b : Bindings, @[scope(b)] c : Block) : Command => @[prec(10)] "procedure " name b c;
#end

def b3Env :=
#strata
program B3Lite;
assert true;
assert (true ==> true) ==> true;
assert true ==> (true ==> true);

procedure add (x : Nat, y : Nat, c : Pred) {
  assign(Pred, a, c);
  if (a) {
    assign(Pred, b, a);
    assign(Pred, c, b);
  } else {
    assign(Pred, b, a);
    assign(Pred, c, b);
  }
}
#end

/--
info: assert true;
assert (true ==> true) ==> true;
assert true ==> true ==> true;
procedure add(x:Nat, y:Nat, c:Pred) {
  assign(Pred, a, c);
  if (a) {
    assign(Pred, b, a);
    assign(Pred, c, b);
  }
  else  {
    assign(Pred, b, a);
    assign(Pred, c, b);
  }
}
-/
#guard_msgs in
#eval IO.println b3Env.format.render

------- @lebjuney's change from here

#strata_gen B3Lite

#print Command
#print Block
#print Binding
#print Bindings
#print Statement
#print Expr
#print B3LiteType


/-
  B3LiteAST is A union type of the types representing syntactic categories.
  This type is used when doing tree traversal on the AST type generated by
  #strata_gen.
-/

-- A 'module' type which is a list of Command. Describes the top-level
-- program. This will be useful. :)
abbrev B3LiteModule := List Command

inductive B3LiteAST where
| module (m:B3LiteModule)
| command (c:Command)
| binding (b:Binding)
| bindings (b:Bindings)
| block (b:Block)
| statement (s:Statement)
| expr (e:Expr)

namespace B3LiteAST

/-
  A depth-first traversal, in a monadic style.
  It receives two monads, one that is called at pre-order visit, and another
  one called at post-order visit.
-/

def depthFirstTraversal {M:Type → Type} [Monad M]
    {RetTyBegin RetTyEnd:Type}
    (pre_m: B3LiteAST → M RetTyBegin)
    (post_m: B3LiteAST → RetTyBegin → List RetTyEnd → M RetTyEnd) :=
  let rec fn (a:B3LiteAST): M RetTyEnd := do
    -- Pre-traversal call
    let res_pre ← pre_m a

    -- Visit children
    let (res_children:List RetTyEnd) ←
      match a with
      | .module m =>
        List.foldlM (fun res_children c => do
            let res ← fn (.command c)
            return (res_children ++ [res]))
          [] m

      | .command c =>
        match c with
        | .assert e =>
          let res ← fn (.expr e)
          pure [res]
        | .procedure _ b blk =>
          let res_binding ← fn (.bindings b)
          let res_block ← fn (.block blk)
          pure [res_binding, res_block]

      | .binding _ =>
        -- Leaf
        pure []

      | .bindings ⟨ bs ⟩ =>
        Array.foldlM (fun res_children b => do
            let res ← fn (.binding b)
            return (res_children ++ [res]))
          [] bs

      | .block ⟨ stmts ⟩ =>
        Array.foldlM (fun res_children stmt => do
            let res ← fn (.statement stmt)
            return (res_children ++ [res]))
          [] stmts

      | .statement s =>
        match s with
        | .assign _ _ e => do
          let res ← fn (.expr e)
          pure [res]
        | .if e bthen belse => do
          let res_cond ← fn (.expr e)
          let res_then ← fn (.block bthen)
          let res_else ← fn (.block belse)
          pure [res_cond,res_then,res_else]

      | .expr e =>
        match e with
        | .fvar _ => do pure []
        | .btrue => do pure []
        | .implies l r => do
          let res_l ← fn (.expr l)
          let res_r ← fn (.expr r)
          pure [res_l, res_r]

    -- Post-order call
    let res_pos ← post_m a res_pre res_children
    return res_pos

  fn


-- Given B3LiteAST which is a union type of Command/Statement/etc
-- and its new children node (which is List B3LiteAST), create a new
-- AST node (which is also B3LiteAST) whose children are replaced with
-- the new_children args.

def reconstruct (m:B3LiteAST) (new_children:List B3LiteAST)
    :Except String B3LiteAST := do

  match m with
  | .module _ =>
    let new_commands ← List.foldlM (fun l (c:B3LiteAST) => do
        match c with
        | .command c0 => return (l ++ [c0])
        | _ => throw "module")
      [] new_children
    return .module new_commands

  | .command (c:Command) =>
    match c, new_children with
    | .assert _, [.expr e] =>
      return .command (.assert e)
    | .procedure s _ _, [.bindings bi, .block bl] =>
      return .command (.procedure s bi bl)
    | _, _ => throw "command"

  | .binding (b:Binding) =>
    match b, new_children with
    | ⟨ s, b3type ⟩, [] =>
      return .binding ⟨ s, b3type ⟩
    | _, _ => throw "binding"

  | .bindings _ =>
    let new_bindings ← List.foldlM (fun l (b:B3LiteAST) => do
        match b with
        | .binding b => return (l ++ [b])
        | _ => throw "bindings")
      [] new_children
    return .bindings ⟨ new_bindings.toArray ⟩

  | .block _ =>
    let new_bindings ← List.foldlM (fun l (b:B3LiteAST) => do
        match b with
        | .binding b => return (l ++ [b])
        | _ => throw "block")
      [] new_children
    return .bindings ⟨ new_bindings.toArray ⟩

  | .statement (s:Statement) =>
    match s, new_children with
    | .assign b3ty name _, [.expr e] =>
      return .statement (.assign b3ty name e)
    | .if _ _ _, [.expr cond, .block bthen, .block belse] =>
      return .statement (.if cond bthen belse)
    | _, _ => throw "statement"

  | .expr e =>
    match e, new_children with
    | .fvar _, [] => return .expr e
    | .btrue, [] => return .expr e
    | .implies _ _, [.expr new_lhs, .expr new_rhs] =>
      return .expr (.implies new_lhs new_rhs)
    | _, _ => throw "expr"


end B3LiteAST

/-
  A simple program transformation!

  This is a pass that (wrongly) transforms 'p => q' into 'q => p'. :)
  It recursively visits the AST nodes and performs this.
-/

def example_bogus_imp_swapper (m:B3LiteModule)
    : Except String B3LiteModule := do

  let ast:B3LiteAST := .module m

  let new_ast ← ast.depthFirstTraversal
    -- The pre-order visit fn does nothing
    (fun x => return x)
    -- The post-order visit fn swaps p ==> q to q ==> p.
    (fun this_node _ (new_children: List B3LiteAST) =>
      match this_node, new_children with
      | .expr (.implies _ _), [new_lhs, new_rhs] =>
        B3LiteAST.reconstruct this_node [new_rhs, new_lhs]
      | _, _ =>
        B3LiteAST.reconstruct this_node new_children)

  match (new_ast:B3LiteAST) with
  | .module m => return m
  | _ => throw "unreachable"



/-

open Strata.BuilderM

abbrev B3LiteBuilderM (α:Type) := Strata.BuilderM (List Command) α

instance: Monad B3LiteBuilderM := Strata.BuilderM.instMonad (List Command)

-- set_option trace.Meta.synthInstance true

namespace B3LiteBuilderM

-- Create a new 'assert' command at the current insertion location.
-- We will want to have this function for each command. :)
def createAssert (p:Expr):
    B3LiteBuilderM (Command × Strata.BuilderM.NodeLoc) :=
  do
    let loc ← getInsertLoc
    let newloc ← loc --IndexTree.freshLocAfter loc
    let new_cmd := Command.assert p


    match old_loc with
    | .none => throw .invalid_location
    | .some [idx] =>
      let (prog_bef,prog_after) := prog.splitAt idx
      let new_cmd := Command.assert p
      let new_prog := prog_bef ++ [new_cmd] ++ prog_after
      let incr_loc:Option Strata.BuilderM.InsertLoc := .some [idx+1]
      set (new_prog, incr_loc)
      return (new_cmd, [idx])
    | _ => throw .unimplemented

end B3LiteBuilderM

-/
