/-
  Copyright Strata Contributors

  SPDX-License-Identifier: Apache-2.0 OR MIT
-/

/-! ## Counter Generator
  This file contains a counter generator `genCounter`, as well as its underlying
  state `CounterState`. The counter is designed to generate a unique number each
  time, and the uniqueness of the generated number can be proven, by keep a
  record of all previous generated numbers (see `CounterState.generated`).

  The uniqueness proof can be derived from the `WF` property on `CounterState`,
  where the next number to be generated is always greater than all previously
  generated numbers, and the previously generated numbers do not contain
  duplicates.

  Also see `LabelGen.lean` for the generic type class for a unique label generator.
-/

namespace Counter

structure CounterState where
  counter : Nat := 0
  generated : List Nat := [] -- a set of numbers generated by the generator

instance : HasSubset CounterState where
  Subset σ₁ σ₂ := σ₁.generated.Subset σ₂.generated

@[simp]
def CounterState.emp : CounterState := { counter := 0, generated := [] }

def WF (σ : CounterState)
  := (∀ c, c ∈ σ.generated → c < σ.counter)
      ∧ σ.generated.Nodup

def genCounter (σ : CounterState)
  : Nat × CounterState
  := (σ.counter, { σ with
      counter := σ.counter + 1,
      generated := σ.counter :: σ.generated
    })

theorem genCounterSubset : genCounter σ = (n, σ') → σ ⊆ σ' := by
  intros Hgen
  simp [genCounter] at Hgen
  simp [← Hgen, HasSubset.Subset]
  intros a Hin
  simp_all

theorem genCounterContains :
  genCounter σ = (n, σ') →
  n ∈ σ'.generated := by
  intros Hgen
  simp [genCounter] at Hgen
  simp [← Hgen]

theorem genCounterValue :
  WF σ →
  genCounter σ = (n, σ') →
  σ.counter = n := by
  intros Hwf Hgen
  simp [genCounter] at Hgen
  exact Hgen.1

theorem emptyCounterWF :
  WF .emp := by simp [WF]

theorem genCounterWFMono :
  WF σ →
  genCounter σ = (n, σ') →
  WF σ' := by
  intros Hwf Hgen
  simp [genCounter] at Hgen
  cases Hgen with
  | intro Hl Hr =>
  simp [← Hr]
  simp [Hl, WF] at *
  cases Hwf with
  | intro HH Hdup =>
  apply And.intro
  . intros a Ha
    specialize HH a Ha
    omega
  . apply And.intro
    . unfold Not
      intros Hcontra
      specialize HH n Hcontra
      omega
    . assumption

abbrev CounterM := StateM CounterState

-- returns the old counter value
def getCounter : CounterM Nat := do
  return (← get).counter

-- returns the collection of generated values
def getGenerated : CounterM (List Nat) := do
  return (← get).generated

-- returns the old counter value, and increment it
def genCounterM : CounterM Nat := do
  modifyGet f where f σ := genCounter σ

end Counter
