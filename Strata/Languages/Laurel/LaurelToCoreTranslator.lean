/-
  Copyright Strata Contributors

  SPDX-License-Identifier: Apache-2.0 OR MIT
-/

import Strata.Languages.Core.Program
import Strata.Languages.Core.Verifier
import Strata.Languages.Core.Statement
import Strata.Languages.Core.Procedure
import Strata.Languages.Core.Options
import Strata.Languages.Laurel.Laurel
import Strata.Languages.Laurel.LiftImperativeExpressions
import Strata.Languages.Laurel.HeapParameterization
import Strata.Languages.Laurel.TypeHierarchy
import Strata.Languages.Laurel.LaurelTypes
import Strata.Languages.Laurel.ModifiesClauses
import Strata.Languages.Laurel.CorePrelude
import Strata.DL.Imperative.Stmt
import Strata.DL.Imperative.MetaData
import Strata.DL.Lambda.LExpr
import Strata.Languages.Laurel.LaurelFormat
import Strata.Util.Tactics

open Core (VCResult VCResults)
open Core (intAddOp intSubOp intMulOp intDivOp intModOp intDivTOp intModTOp intNegOp intLtOp intLeOp intGtOp intGeOp boolAndOp boolOrOp boolNotOp boolImpliesOp strConcatOp)

namespace Strata.Laurel

open Std (Format ToFormat)
open Strata
open Lambda (LMonoTy LTy LExpr)

/-
Translate Laurel HighType to Core Type
-/
def translateType (ty : HighTypeMd) : LMonoTy :=
  match _h : ty.val with
  | .TInt => LMonoTy.int
  | .TBool => LMonoTy.bool
  | .TString => LMonoTy.string
  | .TVoid => LMonoTy.bool -- Using bool as placeholder for void
  | .THeap => .tcons "Heap" []
  | .TTypedField _ => .tcons "Field" []
  | .TSet elementType => Core.mapTy (translateType elementType) LMonoTy.bool
  | .TMap keyType valueType => Core.mapTy (translateType keyType) (translateType valueType)
  | .UserDefined _ => .tcons "Composite" []
  | .TCore s => .tcons s []
  | _ => panic s!"unsupported type {ToFormat.format ty}"
termination_by ty.val
decreasing_by all_goals (first | (cases elementType; term_by_mem) | (cases keyType; term_by_mem) | (cases valueType; term_by_mem))

def lookupType (env : TypeEnv) (name : Identifier) : LMonoTy :=
  match env.find? (fun (n, _) => n == name) with
  | some (_, ty) => translateType ty
  | none => panic s!"could not find variable {name} in environment '{Std.format env}'"

def isFieldName (fieldNames : List Identifier) (name : Identifier) : Bool :=
  fieldNames.contains name

/-- Set of names that are translated to Core functions (not procedures) -/
abbrev FunctionNames := List Identifier

def isCoreFunction (funcNames : FunctionNames) (name : Identifier) : Bool :=
  -- readField, updateField, and Box constructors/destructors are always functions
  name == "readField" || name == "updateField" || name == "increment" ||
  name == "MkHeap" || name == "Heap..data!" || name == "Heap..nextReference!" ||
  name == "MkComposite" || name == "Composite..ref!" || name == "Composite..typeTag!" ||
  name == "BoxInt" || name == "BoxBool" || name == "BoxFloat64" || name == "BoxComposite" ||
  name == "Box..intVal!" || name == "Box..boolVal!" || name == "Box..float64Val!" || name == "Box..compositeVal!" ||
  -- Map operations (select/update are built-in map functions, const creates a constant map)
  name == "select" || name == "update" || name == "const" ||
  -- Type hierarchy functions generated by typeHierarchyTransform
  name == "ancestorsPerType" || name.startsWith "ancestorsFor" || name.endsWith "_TypeTag" ||
  funcNames.contains name

/-- State threaded through expression and statement translation -/
structure TranslateState where
  /-- Diagnostics accumulated during translation -/
  diagnostics : List DiagnosticModel := []
  /-- Constants known to the program (field constants, etc.) -/
  fieldNames : List String := []
  /-- Names of procedures that are translated as Core functions -/
  funcNames : FunctionNames := []

/-- The translation monad: state over Id -/
abbrev TranslateM := StateT TranslateState Id

/-- Emit a diagnostic into the translation state -/
def emitDiagnostic (d : DiagnosticModel) : TranslateM Unit :=
  modify fun s => { s with diagnostics := s.diagnostics ++ [d] }

/-- Run a `TranslateM` action, returning the result and final state -/
def runTranslateM (s : TranslateState) (m : TranslateM α) : α × TranslateState :=
  m s

/--
Translate Laurel StmtExpr to Core Expression using the `TranslateM` monad.
Diagnostics for disallowed constructs are emitted into the monad state.

`isPureContext` should be `true` when translating function bodies or contract expressions.
In that case, disallowed constructs emit `DiagnosticModel` errors into the state.
When `false` (inside a procedure body statement), disallowed constructs `panic!`
because `liftImperativeExpressions` should have already removed them.

`boundVars` tracks names bound by enclosing Forall/Exists quantifiers (innermost first).
When an Identifier matches a bound name at index `i`, it becomes `bvar i` (de Bruijn index)
instead of `fvar`.
-/
def translateExpr (env : TypeEnv) (expr : StmtExprMd)
    (boundVars : List Identifier := []) (isPureContext : Bool := false)
    : TranslateM Core.Expression.Expr := do
  let s ← get
  let fieldNames := s.fieldNames
  let funcNames := s.funcNames
  -- Dummy expression used as placeholder when an error is emitted in pure context
  let dummy := .fvar () (Core.CoreIdent.locl s!"DUMMY_VAR_{env.length}") none
  -- Emit an error in pure context; panic in impure context (lifting invariant violated)
  let disallowed (e : StmtExprMd) (msg : String) : TranslateM Core.Expression.Expr := do
    if isPureContext then
      emitDiagnostic (e.md.toDiagnostic msg)
      return dummy
    else
      panic! s!"translateExpr: {msg} (should have been lifted): {Std.Format.pretty (Std.ToFormat.format e)}"
  match h: expr.val with
  | .LiteralBool b => return .const () (.boolConst b)
  | .LiteralInt i => return .const () (.intConst i)
  | .LiteralString s => return .const () (.strConst s)
  | .Identifier name =>
      -- First check if this name is bound by an enclosing quantifier
      match boundVars.findIdx? (· == name) with
      | some idx =>
          -- Bound variable: use de Bruijn index
          return .bvar () idx
      | none =>
          -- Check if this is a field name (datatype constructor) or local variable
          if isFieldName fieldNames name then
            let ident := Core.CoreIdent.unres name
            return .op () ident none
          else
            return .fvar () (Core.CoreIdent.locl name) (some (lookupType env name))
  | .PrimitiveOp op [e] =>
    match op with
    | .Not =>
      let re ← translateExpr env e boundVars isPureContext
      return .app () boolNotOp re
    | .Neg =>
      let re ← translateExpr env e boundVars isPureContext
      return .app () intNegOp re
    | _ => panic! s!"translateExpr: Invalid unary op: {repr op}"
  | .PrimitiveOp op [e1, e2] =>
    let re1 ← translateExpr env e1 boundVars isPureContext
    let re2 ← translateExpr env e2 boundVars isPureContext
    let binOp (bop : Core.Expression.Expr) : Core.Expression.Expr :=
      LExpr.mkApp () bop [re1, re2]
    match op with
    | .Eq => return .eq () re1 re2
    | .Neq => return .app () boolNotOp (.eq () re1 re2)
    | .And => return binOp boolAndOp
    | .Or => return binOp boolOrOp
    | .Implies => return binOp boolImpliesOp
    | .Add => return binOp intAddOp
    | .Sub => return binOp intSubOp
    | .Mul => return binOp intMulOp
    | .Div => return binOp intDivOp
    | .Mod => return binOp intModOp
    | .DivT => return binOp intDivTOp
    | .ModT => return binOp intModTOp
    | .Lt => return binOp intLtOp
    | .Leq => return binOp intLeOp
    | .Gt => return binOp intGtOp
    | .Geq => return binOp intGeOp
    | .StrConcat => return binOp strConcatOp
    | _ => panic! s!"translateExpr: Invalid binary op: {repr op}"
  | .PrimitiveOp op args =>
    panic! s!"translateExpr: PrimitiveOp {repr op} with {args.length} args"
  | .IfThenElse cond thenBranch elseBranch =>
      let bcond ← translateExpr env cond boundVars isPureContext
      let bthen ← translateExpr env thenBranch boundVars isPureContext
      let belse ← match elseBranch with
        | none => panic "if-then without else expression not yet implemented"
        | some e =>
            have : sizeOf e < sizeOf expr := by
              have := WithMetadata.sizeOf_val_lt expr
              cases expr; simp_all; omega
            translateExpr env e boundVars isPureContext
      return .ite () bcond bthen belse
  | .StaticCall name args =>
      -- In a pure context, only Core functions (not procedures) are allowed
      if isPureContext && !isCoreFunction funcNames name then
        disallowed expr "calls to procedures are not supported in functions or contracts"
      else
        let fnOp : Core.Expression.Expr := .op () (Core.CoreIdent.unres name) none
        args.attach.foldlM (fun acc ⟨arg, _⟩ => do
          let re ← translateExpr env arg boundVars isPureContext
          return .app () acc re) fnOp
  | .Block [single] _ => translateExpr env single boundVars isPureContext

  | .Forall name ty body =>
      let coreTy := translateType ty
      let coreBody ← translateExpr env body (name :: boundVars) isPureContext
      return LExpr.all () (some coreTy) coreBody
  | .Exists name ty body =>
      let coreTy := translateType ty
      let coreBody ← translateExpr env body (name :: boundVars) isPureContext
      return LExpr.exist () (some coreTy) coreBody
  | .Hole => return dummy
  | .ReferenceEquals e1 e2 =>
      let re1 ← translateExpr env e1 boundVars isPureContext
      let re2 ← translateExpr env e2 boundVars isPureContext
      return .eq () re1 re2
  | .Assign _ _ =>
      disallowed expr "destructive assignments are not supported in functions or contracts"
  | .While _ _ _ _ =>
      disallowed expr "loops are not supported in functions or contracts"
  | .Exit _ => disallowed expr "exit is not supported in expression position"

  | .IsType _ _ => panic "IsType should have been lowered"
  | .New _ => panic! s!"New should have been eliminated by typeHierarchyTransform"
  | .FieldSelect target fieldName =>
      -- Field selects should have been eliminated by heap parameterization
      -- If we see one here, it's an error in the pipeline
      panic! s!"FieldSelect should have been eliminated by heap parameterization: {Std.ToFormat.format target}#{fieldName}"

  | .Block _ _ => panic "block expression not yet implemented (should be lowered in a separate pass)"
  | .LocalVariable _ _ _ => panic "local variable expression not yet implemented (should be lowered in a separate pass)"
  | .Return _ => disallowed expr "return expression not yet implemented (should be lowered in a separate pass)"

  | .AsType target _ => panic "AsType expression not implemented"
  | .Assigned _ => panic "assigned expression not implemented"
  | .Old value => panic "old expression not implemented"
  | .Fresh _ => panic "fresh expression not implemented"
  | .Assert _ => panic "assert expression not implemented"
  | .Assume _ => panic "assume expression not implemented"
  | .ProveBy value _ => panic "proveBy expression not implemented"
  | .ContractOf _ _ => panic "contractOf expression not implemented"
  | .Abstract => panic "abstract expression not implemented"
  | .All => panic "all expression not implemented"
  | .InstanceCall _ _ _ => panic "InstanceCall not implemented"
  | .PureFieldUpdate _ _ _ => panic "This expression not implemented"
  | .This => panic "This expression not implemented"
  termination_by expr
  decreasing_by
    all_goals (have := WithMetadata.sizeOf_val_lt expr; term_by_mem)

def getNameFromMd (md : Imperative.MetaData Core.Expression): String :=
  let fileRange := (Imperative.getFileRange md).getD (panic "getNameFromMd bug")
  s!"({fileRange.range.start})"

def defaultExprForType (ty : HighTypeMd) : Core.Expression.Expr :=
  match ty.val with
  | .TInt => .const () (.intConst 0)
  | .TBool => .const () (.boolConst false)
  | .TString => .const () (.strConst "")
  | _ =>
    -- For types without a natural default (arrays, composites, etc.),
    -- use a fresh free variable. This is only used when the value is
    -- immediately overwritten by a procedure call.
    let coreTy := translateType ty
    .fvar () (Core.CoreIdent.locl "$default") (some coreTy)

/--
Translate Laurel StmtExpr to Core Statements using the `TranslateM` monad.
Diagnostics are emitted into the monad state.
-/
def translateStmt (env : TypeEnv) (outputParams : List Parameter) (stmt : StmtExprMd)
    : TranslateM (TypeEnv × List Core.Statement) := do
  let s ← get
  let functionNames := s.funcNames
  let md := stmt.md
  match _h : stmt.val with
  | @StmtExpr.Assert cond =>
      -- Assert/assume bodies must be pure expressions (no assignments, loops, or procedure calls)
      let coreExpr ← translateExpr env cond [] (isPureContext := true)
      return (env, [Core.Statement.assert ("assert" ++ getNameFromMd md) coreExpr md])
  | @StmtExpr.Assume cond =>
      let coreExpr ← translateExpr env cond [] (isPureContext := true)
      return (env, [Core.Statement.assume ("assume" ++ getNameFromMd md) coreExpr md])
  | .Block stmts _ =>
      let (env', stmtsList) ← stmts.attach.foldlM (fun (e, acc) ⟨s, _hs⟩ => do
        let (e', ss) ← translateStmt e outputParams s
        return (e', acc ++ ss)) (env, [])
      return (env', stmtsList)
  | .LocalVariable name ty initializer =>
      let env' := (name, ty) :: env
      let boogieMonoType := translateType ty
      let boogieType := LTy.forAll [] boogieMonoType
      let ident := Core.CoreIdent.locl name
      match initializer with
      | some (⟨ .StaticCall callee args, callMd⟩) =>
          -- Check if this is a function or a procedure call
          if isCoreFunction functionNames callee then
            -- Translate as expression (function application)
            let boogieExpr ← translateExpr env (⟨ .StaticCall callee args, callMd ⟩)
            return (env', [Core.Statement.init ident boogieType (some boogieExpr) md])
          else
            -- Translate as: var name; call name := callee(args)
            let coreArgs ← args.mapM (fun a => translateExpr env a)
            let defaultExpr := defaultExprForType ty
            let initStmt := Core.Statement.init ident boogieType (some defaultExpr) md
            let callStmt := Core.Statement.call [ident] callee coreArgs md
            return (env', [initStmt, callStmt])
      | some initExpr =>
          let coreExpr ← translateExpr env initExpr
          return (env', [Core.Statement.init ident boogieType (some coreExpr) md])
      | none =>
          let defaultExpr := defaultExprForType ty
          return (env', [Core.Statement.init ident boogieType (some defaultExpr) md])
  | .Assign targets value =>
      match targets with
      | [⟨ .Identifier name, _ ⟩] =>
          let ident := Core.CoreIdent.locl name
          -- Check if RHS is a procedure call (not a function)
          match value.val with
          | .StaticCall callee args =>
              if isCoreFunction functionNames callee then
                -- Functions are translated as expressions
                let boogieExpr ← translateExpr env value
                return (env, [Core.Statement.set ident boogieExpr md])
              else
                -- Procedure calls need to be translated as call statements
                let coreArgs ← args.mapM (fun a => translateExpr env a)
                return (env, [Core.Statement.call [ident] callee coreArgs md])
          | _ =>
              let boogieExpr ← translateExpr env value
              return (env, [Core.Statement.set ident boogieExpr md])
      | _ =>
          -- Parallel assignment: (var1, var2, ...) := expr
          -- Example use is heap-modifying procedure calls: (result, heap) := f(heap, args)
          match value.val with
          | .StaticCall callee args =>
              let coreArgs ← args.mapM (fun a => translateExpr env a)
              let lhsIdents := targets.filterMap fun t =>
                match t.val with
                | .Identifier name => some (Core.CoreIdent.locl name)
                | _ => none
              return (env, [Core.Statement.call lhsIdents callee coreArgs value.md])
          | _ =>
              panic "Assignments with multiple target but without a RHS call should not be constructed"
  | .IfThenElse cond thenBranch elseBranch =>
      let bcond ← translateExpr env cond
      let (_, bthen) ← translateStmt env outputParams thenBranch
      let belse ← match elseBranch with
                  | some e => (·.2) <$> translateStmt env outputParams e
                  | none => pure []
      return (env, [Imperative.Stmt.ite bcond bthen belse .empty])
  | .StaticCall name args =>
      -- Check if this is a function or procedure
      if isCoreFunction functionNames name then
        -- Functions as statements have no effect (shouldn't happen in well-formed programs)
        return (env, [])
      else
        let coreArgs ← args.mapM (fun a => translateExpr env a)
        return (env, [Core.Statement.call [] name coreArgs md])
  | .Return valueOpt =>
      match valueOpt, outputParams.head? with
      | some value, some outParam =>
          let ident := Core.CoreIdent.locl outParam.name
          let coreExpr ← translateExpr env value
          let assignStmt := Core.Statement.set ident coreExpr md
          let noFallThrough := Core.Statement.assume "return" (.const () (.boolConst false)) .empty
          return (env, [assignStmt, noFallThrough])
      | none, _ =>
          let noFallThrough := Core.Statement.assume "return" (.const () (.boolConst false)) .empty
          return (env, [noFallThrough])
      | some _, none =>
          panic! "Return statement with value but procedure has no output parameters"
  | .While cond invariants decreasesExpr body =>
      let condExpr ← translateExpr env cond
      let invExprs ← invariants.mapM (translateExpr env)
      let decreasingExprCore ← decreasesExpr.mapM (translateExpr env)
      let (_, bodyStmts) ← translateStmt env outputParams body
      return (env, [Imperative.Stmt.loop condExpr decreasingExprCore invExprs bodyStmts md])
  | _ => return (env, [])
  termination_by sizeOf stmt
  decreasing_by
    all_goals
      have hlt := WithMetadata.sizeOf_val_lt stmt
      cases stmt; term_by_mem

/--
Translate a list of checks (preconditions or postconditions) to Core checks.
Each check gets a label like `"requires"` or `"requires_0"`, `"requires_1"`, etc.
-/
private def translateChecks (env : TypeEnv) (checks : List StmtExprMd) (labelBase : String)
    : TranslateM (ListMap Core.CoreLabel Core.Procedure.Check) :=
  checks.mapIdxM (fun i check => do
    let label := if checks.length == 1 then labelBase else s!"{labelBase}_{i}"
    let checkExpr ← translateExpr env check [] (isPureContext := true)
    let c : Core.Procedure.Check := { expr := checkExpr, md := check.md }
    return (label, c))

/--
Translate Laurel Parameter to Core Signature entry
-/
def translateParameterToCore (param : Parameter) : (Core.CoreIdent × LMonoTy) :=
  let ident := Core.CoreIdent.locl param.name
  let ty := translateType param.type
  (ident, ty)

/--
Translate Laurel Procedure to Core Procedure using `TranslateM`.
Diagnostics from disallowed constructs in preconditions, postconditions, and body
are emitted into the monad state.
-/
def translateProcedure (proc : Procedure) : TranslateM Core.Procedure := do
  let inputPairs := proc.inputs.map translateParameterToCore
  let inputs := inputPairs
  let outputs := proc.outputs.map translateParameterToCore
  let header : Core.Procedure.Header := {
    name := proc.name
    typeArgs := []
    inputs := inputs
    outputs := outputs
  }
  let initEnv : TypeEnv := proc.inputs.map (fun p => (p.name, p.type)) ++
                           proc.outputs.map (fun p => (p.name, p.type))
  -- Translate preconditions
  let preconditions ← translateChecks initEnv proc.preconditions "requires"

  -- Translate postconditions for Opaque bodies
  let postconditions : ListMap Core.CoreLabel Core.Procedure.Check ←
    match proc.body with
    | .Opaque postconds _ _ =>
        translateChecks initEnv postconds "postcondition"
    | _ => pure []
  let modifies : List Core.Expression.Ident := []
  let body : List Core.Statement ←
    match proc.body with
    | .Transparent bodyExpr => (·.2) <$> translateStmt initEnv proc.outputs bodyExpr
    | .Opaque _postconds (some impl) _ => (·.2) <$> translateStmt initEnv proc.outputs impl
    | _ => pure [Core.Statement.assume "no_body" (.const () (.boolConst false)) .empty]
  let spec : Core.Procedure.Spec := { modifies, preconditions, postconditions }
  return { header, spec, body }

/--
Check if a Laurel expression is pure (contains no side effects).
Used to determine if a procedure can be translated as a Core function.
-/
private def isPureExpr(expr: StmtExprMd): Bool :=
  match _h : expr.val with
  | .LiteralBool _ => true
  | .LiteralInt _ => true
  | .LiteralString _ => true
  | .Identifier _ => true
  | .PrimitiveOp _ args => args.attach.all (fun ⟨a, _⟩ => isPureExpr a)
  | .IfThenElse c t none => isPureExpr c && isPureExpr t
  | .IfThenElse c t (some e) => isPureExpr c && isPureExpr t && isPureExpr e
  | .StaticCall _ args => args.attach.all (fun ⟨a, _⟩ => isPureExpr a)
  | .New _ => false
  | .ReferenceEquals e1 e2 => isPureExpr e1 && isPureExpr e2
  | .Block [single] _ => isPureExpr single
  | .Block _ _ => false
  -- Statement-like
  | .LocalVariable .. => true
  | .While .. => false
  | .Exit .. => false
  | .Return .. => false
  -- Expression-like
  | .Assign .. => false
  | .FieldSelect .. => true
  | .PureFieldUpdate .. => true
  -- Instance related
  | .This => panic s!"isPureExpr not implemented for This"
  | .AsType .. => panic s!"isPureExpr not supported for AsType"
  | .IsType .. => panic s!"isPureExpr not supported for IsType"
  | .InstanceCall .. => panic s!"isPureExpr not implemented for InstanceCall"
  -- Verification specific
  | .Forall .. => panic s!"isPureExpr not implemented for Forall"
  | .Exists .. => panic s!"isPureExpr not implemented for Exists"
  | .Assigned .. => panic s!"isPureExpr not supported for AsType"
  | .Old .. => panic s!"isPureExpr not supported for AsType"
  | .Fresh .. => panic s!"isPureExpr not supported for AsType"
  | .Assert .. => panic s!"isPureExpr not implemented for Assert"
  | .Assume .. => panic s!"isPureExpr not implemented for Assume"
  | .ProveBy .. => panic s!"isPureExpr not implemented for ProveBy"
  | .ContractOf .. => panic s!"isPureExpr not implemented for ContractOf"
  | .Abstract => panic s!"isPureExpr not implemented for Abstract"
  | .All => panic s!"isPureExpr not implemented for All"
  -- Dynamic / closures
  | .Hole => true
  termination_by sizeOf expr
  decreasing_by all_goals (have := WithMetadata.sizeOf_val_lt expr; term_by_mem)

/-- Check if a pure-marked procedure can actually be represented as a Core function:
    transparent body that is a pure expression and has exactly one output. -/
private def canBeCoreFunctionBody (proc : Procedure) : Bool :=
  match proc.body with
  | .Transparent bodyExpr =>
    isPureExpr bodyExpr &&
    proc.outputs.length == 1
  | .Opaque _ bodyExprOption _ =>
    (bodyExprOption.map isPureExpr).getD true &&
    proc.outputs.length == 1
  | _ => false

/--
Translate a Laurel Procedure to a Core Function (when applicable) using `TranslateM`.
Diagnostics for disallowed constructs in the function body are emitted into the monad state.
-/
def translateProcedureToFunction (proc : Procedure) : TranslateM Core.Decl := do
  let inputs := proc.inputs.map translateParameterToCore
  let outputTy := match proc.outputs.head? with
    | some p => translateType p.type
    | none => LMonoTy.int
  let initEnv : TypeEnv := proc.inputs.map (fun p => (p.name, p.type))
  -- Translate precondition to FuncPrecondition (skip trivial `true`)
  let preconditions ← proc.preconditions.mapM (fun precondition => do
    let checkExpr ← translateExpr initEnv precondition [] true
    return { expr := checkExpr, md := () })

  let body ← match proc.body with
    | .Transparent bodyExpr => some <$> translateExpr initEnv bodyExpr [] (isPureContext := true)
    | .Opaque _ (some bodyExpr) _ =>
      emitDiagnostic (proc.md.toDiagnostic "functions with postconditions are not yet supported")
      some <$> translateExpr initEnv bodyExpr [] (isPureContext := true)
    | _ => pure none
  return .func {
    name := Core.CoreIdent.unres proc.name
    typeArgs := []
    inputs := inputs
    output := outputTy
    body := body
    preconditions := preconditions
  }

/--
Translate a Laurel DatatypeDefinition to a Core type declaration.
Zero constructors produces an opaque (abstract) type; otherwise a Core datatype.
-/
def translateDatatypeDefinition (dt : DatatypeDefinition) : Core.Decl :=
  match h : dt.constructors with
  | [] =>
    -- Zero constructors: opaque type
    Core.Decl.type (.con { name := dt.name, numargs := dt.typeArgs.length })
  | first :: rest =>
    let constrs : List (Lambda.LConstr Core.Visibility) := (first :: rest).map fun c =>
      { name := Core.CoreIdent.unres c.name
        args := c.args.map fun (n, ty) => (Core.CoreIdent.unres n, translateType ty) }
    let ldt : Lambda.LDatatype Core.Visibility := {
      name := dt.name
      typeArgs := dt.typeArgs
      constrs := constrs
      constrs_ne := by simp [constrs]
    }
    Core.Decl.type (.data [ldt])

/--
Try to translate a Laurel Procedure marked `isFunctional` to a Core Function.
Returns `.error` with diagnostics if the procedure body contains disallowed constructs
(destructive assignments, loops, or procedure calls).
-/
def tryTranslatePureToFunction (proc : Procedure) (initState : TranslateState)
    : Except (Array DiagnosticModel) Core.Decl :=
  let (decl, finalState) := runTranslateM initState (translateProcedureToFunction proc)
  if finalState.diagnostics.isEmpty then
    .ok decl
  else
    .error finalState.diagnostics.toArray

/--
Translate Laurel Program to Core Program
-/
def translate (program : Program) : Except (Array DiagnosticModel) (Core.Program × Array DiagnosticModel) := do
  let program := heapParameterization program
  let program := typeHierarchyTransform program
  let (program, modifiesDiags) := modifiesClausesTransform program
  dbg_trace "===  Program after heapParameterization + modifiesClausesTransform ==="
  dbg_trace (toString (Std.Format.pretty (Std.ToFormat.format program)))
  dbg_trace "================================="
  let program := liftImperativeExpressions program
  -- Collect field names from the Field datatype (generated by heapParameterization)
  let fieldNames : List Identifier := program.types.foldl (fun acc td =>
    match td with
    | .Datatype dt => if dt.name == "Field" then acc ++ dt.constructors.map (·.name) else acc
    | _ => acc) []

  -- Procedures marked isFunctional are translated to Core functions; all others become Core procedures.
  let (markedPure, procProcs) := program.staticProcedures.partition (·.isFunctional)
  -- Build the shared initial state with constants and function names
  let funcNames : FunctionNames := markedPure.map (·.name)
  let initState : TranslateState := { fieldNames := fieldNames, funcNames }
  -- Try to translate each isFunctional procedure to a Core function, collecting errors for failures
  let (pureErrors, pureFuncDecls) := markedPure.foldl (fun (errs, decls) p =>
    match tryTranslatePureToFunction p initState with
    | .error es => (errs ++ es.toList, decls)
    | .ok d     => (errs, decls.push d)) ([], #[])
  -- Translate procedures using the monad, collecting diagnostics from the final state
  let (procedures, procState) := runTranslateM initState do
    procProcs.mapM translateProcedure
  let procDiags := procState.diagnostics

  -- Translate Laurel constants to Core function declarations (0-ary functions)
  let (constantDecls, constantsState) := runTranslateM initState $ program.constants.mapM fun c => do
    let coreTy := translateType c.type
    let body ← c.initializer.mapM (translateExpr [] ·)
    return Core.Decl.func {
      name := Core.CoreIdent.unres c.name
      typeArgs := []
      inputs := []
      output := coreTy
      body := body
    }

  -- Collect ALL errors from both functions and procedures before deciding whether to fail
  let allErrors := pureErrors ++ procDiags ++ constantsState.diagnostics
  if !allErrors.isEmpty then
    .error allErrors.toArray
  let procDecls := procedures.map (fun p => Core.Decl.proc p .empty)

  -- Filter out the Field and TypeTag opaque types. These are only in the prelude to satisfy the DDM type checker.
  let preludeDecls := corePrelude.decls.filter fun d =>
    d.name.name != "Field" && d.name.name != "TypeTag"

  -- Translate Laurel datatype definitions to Core datatype declarations
  let laurelDatatypeDecls := program.types.filterMap fun td => match td with
    | .Datatype dt => some (translateDatatypeDefinition dt)
    | _ => none
  pure ({ decls := laurelDatatypeDecls ++ preludeDecls ++ constantDecls ++ pureFuncDecls.toList ++ procDecls }, modifiesDiags)

/--
Verify a Laurel program using an SMT solver
-/
def verifyToVcResults (program : Program)
    (options : Options := Options.default)
    : IO (Except (Array DiagnosticModel) VCResults) := do
  let (strataCoreProgram, translateDiags) ← match translate program with
    | .error translateErrorDiags => return .error translateErrorDiags
    | .ok result => pure result

  -- Enable removeIrrelevantAxioms to avoid polluting simple assertions with heap axioms
  let options := { options with removeIrrelevantAxioms := true }
  -- Debug: Print the generated Strata Core program
  dbg_trace "=== Generated Strata Core Program ==="
  dbg_trace (toString (Std.Format.pretty (Strata.Core.formatProgram strataCoreProgram) 100))
  dbg_trace "================================="
  let runner tempDir :=
    EIO.toIO (fun f => IO.Error.userError (toString f))
        (Core.verify strataCoreProgram tempDir .none options)
  let ioResult ← match options.vcDirectory with
    | .none => IO.FS.withTempDir runner
    | .some p => IO.FS.createDirAll ⟨p.toString⟩; runner ⟨p.toString⟩
  if translateDiags.isEmpty then
    return .ok ioResult
  else
    return .error (translateDiags ++ ioResult.filterMap toDiagnosticModel)


def verifyToDiagnostics (files: Map Strata.Uri Lean.FileMap) (program : Program)
    (options : Options := Options.default): IO (Array Diagnostic) := do
  -- Validate for diamond-inherited field accesses before translation
  let uri := files.keys.head!
  let diamondErrors := validateDiamondFieldAccesses uri program
  if !diamondErrors.isEmpty then
    return diamondErrors.map (fun dm => dm.toDiagnostic files)
  let results <- verifyToVcResults program options
  match results with
  | .error errors => return errors.map (fun dm => dm.toDiagnostic files)
  | .ok results => return results.filterMap (fun dm => dm.toDiagnostic files)


def verifyToDiagnosticModels (program : Program) (options : Options := Options.default) : IO (Array DiagnosticModel) := do
  let results <- verifyToVcResults program options
  match results with
  | .error errors => return errors
  | .ok results => return results.filterMap toDiagnosticModel

end Laurel
