/-
  Copyright Strata Contributors

  SPDX-License-Identifier: Apache-2.0 OR MIT
-/

import Strata.Languages.Core.DDMTransform.Parse
import Strata.Languages.Core.Program
import Strata.Languages.Core.CoreGen
import Strata.DDM.Util.SourceRange

/-!
# Core CST ↔ Core.Program Bidirectional Conversion

This module provides bidirectional conversion between Core CST types
(generated by DDM) and Core.Program AST types.

## CoreCST → Core.Program Conversion
Converts concrete syntax (generated AST from DDM) to Core abstract
syntax. Used for parsing Core syntax via DDM and converting it to
Core.Program.

## Core.Program → CoreCST Conversion
Converts Core abstract syntax to concrete syntax (generated AST).
Used for formatting and pretty-printing Core constructs using DDM's
formatting system.
-/

namespace Strata

open Core
open Strata.CoreDDM

---------------------------------------------------------------------
-- Conversion Errors
---------------------------------------------------------------------

/-- Errors that can occur during CST→AST conversion (parsing) -/
inductive CSTToASTError (M : Type) where
  | unresolvedIdentifier (name : String) (metadata : M) :
      CSTToASTError M
  | typeMismatch (expected : String) (got : String) (metadata : M) :
      CSTToASTError M
  deriving Repr, Inhabited

namespace CSTToASTError

def toString [ToString M] : CSTToASTError M → String
  | unresolvedIdentifier name _m => s!"Unresolved identifier '{name}'"
  | typeMismatch expected got _m => s!"Type mismatch: expected {expected}, got {got}"

instance [ToString M] : ToString (CSTToASTError M) where
  toString := CSTToASTError.toString

end CSTToASTError

instance [ToString M] : ToString (List (CSTToASTError M)) where
  toString errs := toString errs.toArray

/-- Errors that can occur during AST→CST conversion (formatting) -/
inductive ASTToCSTError (M : Type) where
  | unsupportedConstruct (description : String) (metadata : M) :
      ASTToCSTError M
  deriving Inhabited

namespace ASTToCSTError

def toString [ToString M] : ASTToCSTError M → String
  | unsupportedConstruct desc _m => s!"Unsupported construct: {desc}"

instance [ToString M] : ToString (ASTToCSTError M) where
  toString := ASTToCSTError.toString

end ASTToCSTError

---------------------------------------------------------------------
-- CoreCST → Core.Program Conversion (Concrete to Abstract)
---------------------------------------------------------------------

section FromCST

structure FromCSTContext where
  fileName : String

namespace FromCSTContext

def empty : FromCSTContext := { fileName := "<unknown>" }

end FromCSTContext

-- Convert SourceRange to metadata
def sourceRangeToMetaData (fileName : String) (sr : SourceRange) :
    Imperative.MetaData Core.Expression :=
  let uri : Uri := .file fileName
  let fileRangeElt := ⟨Imperative.MetaData.fileRange, .fileRange ⟨uri, sr⟩⟩
  #[fileRangeElt]

-- Translate CoreType to LMonoTy
def translateCoreType (ty : CoreType SourceRange) : Lambda.LMonoTy :=
  match ty with
  | .bool _ => .tcons "bool" []
  | .int _ => .int
  | .string _ => .tcons "string" []
  | .regex _ => .tcons "regex" []
  | .real _ => .real
  | .bv1 _ => .bitvec 1
  | .bv8 _ => .bitvec 8
  | .bv16 _ => .bitvec 16
  | .bv32 _ => .bitvec 32
  | .bv64 _ => .bitvec 64
  | .Map _ k v => .tcons "Map" [translateCoreType k, translateCoreType v]

-- Convert a Command to a Core.Decl
def commandFromCST (ctx : FromCSTContext)
    (cmd : Command SourceRange) :
    Core.Decl × List (CSTToASTError SourceRange) :=
  match cmd with
  | .command_typedecl ann name args =>
    let typeName := name.val
    let numargs := match args.val with
      | none => 0
      | some (.mkBindings _ bindings) => bindings.val.size
    let md := sourceRangeToMetaData ctx.fileName ann
    let decl := Core.Decl.type
      (.con { name := typeName, numargs := numargs }) md
    (decl, [])
  | .command_typesynonym ann name args _targs rhs =>
    let typeName := name.val
    let typeArgs := match args.val with
      | none => []
      | some (.mkBindings _ bindings) =>
        bindings.val.toList.map fun b =>
          match b with
          | .mkBinding _ nameAnn _ => nameAnn.val
    let md := sourceRangeToMetaData ctx.fileName ann
    let decl := Core.Decl.type
      (.syn { name := typeName, typeArgs := typeArgs,
              type := translateCoreType rhs }) md
    (decl, [])
  | _ =>
    let ann := default
    let md := sourceRangeToMetaData ctx.fileName ann
    let decl := Core.Decl.type
      (.con { name := "TODO", numargs := 0 }) md
    (decl, [.typeMismatch "implemented command"
      "unimplemented command" ann])

-- Convert a Program (list of Commands) to Core.Program
def programFromCST (ctx : FromCSTContext)
    (cmds : List (Command SourceRange)) :
    Core.Program × List (CSTToASTError SourceRange) :=
  let results := cmds.map (commandFromCST ctx)
  let decls := results.map (·.1)
  let errors := results.flatMap (·.2)
  ({ decls := decls }, errors)

end FromCST

---------------------------------------------------------------------
-- Core.Program → CoreCST Conversion (Abstract to Concrete)
---------------------------------------------------------------------

section ToCST

structure ToCSTContext where
  -- TODO: Add context for formatting
  dummy : Unit := ()

namespace ToCSTContext

def empty : ToCSTContext := {}

end ToCSTContext

-- Stub: Convert a Core.Decl to a Command
def declToCST [Inhabited M] (ctx : ToCSTContext) (decl : Core.Decl) :
    Command M × List (ASTToCSTError M) :=
  sorry -- TODO: Implement

-- Stub: Convert Core.Program to a list of Commands
def programToCST [Inhabited M] (ctx : ToCSTContext)
    (prog : Core.Program) :
    List (Command M) × List (ASTToCSTError M) :=
  sorry -- TODO: Implement

end ToCST

---------------------------------------------------------------------

end Strata
